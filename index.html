<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Love You So Much Effect</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0) !important;
  overflow: hidden;
}
#stage {
  position: absolute;
  left: 50%;
  top: 0;
  width: calc(100% + 320px);
  height: 100%;
  transform: translateX(-50%);
  pointer-events: none;
}
.effect-item {
  position: absolute;
  will-change: transform, opacity;
}
</style>
</head>
<body>

<div id="stage"></div>

<script>
const stage = document.getElementById("stage");
const effect = {
  image: "Love_you_so_much.png",
  type: "love_spike",
  countLimit: 1,
  duration: 4000,
  spawnInterval: 0,
  start: { x: [0.1,0.15], y: [0.7,0.75], sizeRatio: [0.08,0.1] },
  end: { x: [0.5,0.6], y: [0.35,0.4], sizeRatio: [0.08,0.1] },
  spike: { image: "Spike.png", sizeRatio: [0.12,0.16], rotation: -45, duration: 600 }
};
const CHARGE_TIME=500;
const rand=(a,b)=>Math.random()*(b-a)+a;

const items=[];

function spawnItem(){
  const W=stage.clientWidth,H=stage.clientHeight;
  const img=document.createElement("img");
  img.src=effect.image;
  img.className="effect-item";
  const ss=rand(...effect.start.sizeRatio)*W;
  const es=rand(...effect.end.sizeRatio)*W;
  const sx=rand(...effect.start.x.map(v=>v*W));
  const sy=rand(...effect.start.y.map(v=>v*H));
  const ex=rand(...effect.end.x.map(v=>v*W));
  const ey=rand(...effect.end.y.map(v=>v*H));
  img.style.width=ss+"px";
  img.style.opacity=1;
  stage.appendChild(img);
  items.push({el:img, sx,sy, ex,ey, ss,es, startTime:performance.now(), vy:0, falling:false, spikeEl:null});
}

spawnItem();

function animate(now){
  const W=stage.clientWidth,H=stage.clientHeight;
  items.forEach(it=>{
    if(it.dead) return;
    const elapsed=now-it.startTime;
    const t=Math.min(elapsed/effect.duration,1);
    let x=it.sx, y=it.sy, size=it.ss, rotate=0;

    // 震え
    if(elapsed<CHARGE_TIME){
      const shake=Math.sin(elapsed/80)*6;
      x=it.sx+shake; y=it.sy;
      rotate=shake*0.5;
    }
    else{
      // 飛行
      const flyT=Math.min((elapsed-CHARGE_TIME)/(effect.duration-CHARGE_TIME),1);
      x=it.sx+(it.ex-it.sx)*flyT;
      y=it.sy+(it.ey-it.sy)*flyT;
      size=it.ss+(it.es-it.ss)*flyT;
      rotate=(1-flyT)*360;

      // Spike生成
      if(!it.spikeEl){
        const spike=document.createElement("img");
        spike.src=effect.spike.image;
        spike.className="effect-item";
        const spikeSize=rand(...effect.spike.sizeRatio)*W;
        spike.style.width=spikeSize+"px";
        spike.style.opacity=1;
        stage.appendChild(spike);
        it.spikeEl=spike;
      }

      // Spike追従＋反時計回り
      if(it.spikeEl){
        const spikeX=x+size/2;
        const spikeY=y-size/2;
        it.spikeEl.style.transform=`translate(${spikeX}px, ${spikeY}px) rotate(${effect.spike.rotation}deg)`;
      }

      // Love到着→下に落とす
      if(flyT>=1 && !it.falling){
        it.falling=true;
        it.vy=25;
        it.ey=H*0.65;
      }
    }

    // 下落
    if(it.falling){
      it.vy+=1.5;
      y+=it.vy;
      x=W*0.55;
      if(y>=it.ey){
        y=it.ey;
        if(it.spikeEl){it.spikeEl.remove(); it.spikeEl=null;}
      }
    }

    it.el.style.transform=`translate(${x-size/2}px, ${y-size/2}px) rotate(${rotate}deg)`;
    it.el.style.width=size+"px";

    if(elapsed>effect.duration){it.el.remove(); it.dead=true;}
  });
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>

</body>
</html>
