<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Gift Effect Engine</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: transparent;
  overflow: hidden;
}

#stage {
  position: absolute;
  left: 50%;
  top: 0;
  width: calc(100% + 320px);
  height: 100%;
  transform: translateX(-50%);
  pointer-events: none;
}

.effect-item {
  position: absolute;
  will-change: transform, opacity;
}
</style>
</head>
<body>

<div id="stage"></div>

<script>
/* ==============================
   ğŸ ã‚®ãƒ•ãƒˆå®šç¾©
================================ */
const GIFT_EFFECTS = {
  heart_me: {
    image: "Heart_Me.png",
    type: "pop",
    countLimit: 1,
    duration: 4000,
    spawnInterval: 0,
    start: { sizeRatio: [0.15, 0.15] }
  },

  cool_love: {
    image: "Cool_love.png",
    type: "pop",
    countLimit: 1,
    duration: 4000,
    spawnInterval: 0,
    start: { sizeRatio: [0.11, 0.11] }
  },

  popular_vote: {
    image: "Popular_Vote.png",
    type: "popular",
    countLimit: 20,
    duration: 3000,          // floatç›¸å½“
    spawnInterval: 150,
    start: {
      x: [0.15, 0.20],       // å·¦ä¸‹ãƒ»ç‹­ã‚
      y: [0.77, 0.83],
      sizeRatio: [0.12, 0.12]
    },
    end: {
      x: [0.85, 0.95],       // çœŸã‚“ä¸­ä»˜è¿‘
      y: [-0.15, -0.05]     // ç”»é¢å¤–ã§æ¶ˆã™
    }
  },

  baseball: {
    image: "Baseball.png",
    type: "throw",
    countLimit: 20,
    duration: 3200,
    spawnInterval: 120,
    start: {
      x: [0.48, 0.52],
      y: [0.67, 0.70],
      sizeRatio: [0.1, 0.125]
    },
    end: {
      x: [0.35, 0.55],
      y: [0.2, 0.4],
      sizeRatio: [0.05, 0.075]
    }
  },

  surprised_fish: {
    image: "Surprised_Fish.png",
    type: "float",
    countLimit: 30,
    duration: 6000,
    spawnInterval: 150,
    start: {
      x: [-0.15, -0.05],
      y: [0.25, 0.6],
      sizeRatio: [0.05, 0.06]
    },
    end: {
      x: [1.05, 1.15],
      y: [0.25, 0.6],
      sizeRatio: [0.05, 0.06]
    }
  }
};

/* ==============================
   å®šæ•°ï¼ˆthrowåŸå‹ï¼‰
================================ */
const CHARGE_TIME = 500;
const SHAKE_POWER = 8;
const IMPACT_BOUNCE = 32;

/* ==============================
   ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
================================ */
const rand = (a, b) => Math.random() * (b - a) + a;
const easeOutExpo = t => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));

function parseGiftText(text) {
  // ä¾‹: "Heart Me(1) x 1"
  const match = text.match(/^(.+?)\(\d+\)\s*x\s*(\d+)$/);

  if (!match) return null;

  const gift = match[1]
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "_");

  const count = parseInt(match[2], 10);

  return { gift, count };
}
  
/* ==============================
   URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆãƒ¯ãƒ³ã‚³ãƒ¡å¯¾å¿œï¼‰
================================ */
const params = new URLSearchParams(location.search);

// ãƒ¯ãƒ³ã‚³ãƒ¡ã‹ã‚‰æ¥ã‚‹æ–‡å­—åˆ—
// ä¾‹: "Heart Me(1) x 1"
const rawText = params.get("text");

// gift / n ãŒç›´æ¥æ¥ãŸå ´åˆï¼ˆä¿é™ºï¼‰
let giftKey = params.get("gift");
let rawCount = parseInt(params.get("n"), 10);

// ãƒ¯ãƒ³ã‚³ãƒ¡å½¢å¼ã‚’ãƒ‘ãƒ¼ã‚¹
if (rawText) {
  const parsed = parseGiftText(rawText);
  if (parsed) {
    giftKey = parsed.gift;
    rawCount = parsed.count;
  }
}

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
giftKey = giftKey || "heart_me";
rawCount = rawCount || 1;

const effect = GIFT_EFFECTS[giftKey];
const COUNT = Math.min(rawCount, effect.countLimit);

/* ==============================
   ã‚¹ãƒ†ãƒ¼ã‚¸
================================ */
const stage = document.getElementById("stage");
const W = stage.clientWidth;
const H = stage.clientHeight;

/* ==============================
   ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆï¼ˆä¹±æ•°ã¯ã“ã“ã ã‘ï¼‰
================================ */
const items = [];

function spawnItem() {
  const img = document.createElement("img");
  img.src = effect.image;
  img.className = "effect-item";

  const ss = rand(...effect.start.sizeRatio) * W;
  const es = effect.end?.sizeRatio
    ? rand(...effect.end.sizeRatio) * W
    : ss;

  const item = {
    el: img,
    startTime: performance.now(),
    ss,
    es,
    phase: Math.random() * Math.PI * 2,
    rotBase: rand(-25, 25),
    dead: false,

    sx: effect.start.x ? rand(effect.start.x[0] * W, effect.start.x[1] * W) : W / 2,
    sy: effect.start.y ? rand(effect.start.y[0] * H, effect.start.y[1] * H) : H,
    ex: effect.end?.x ? rand(effect.end.x[0] * W, effect.end.x[1] * W) : W / 2,
    ey: effect.end?.y ? rand(effect.end.y[0] * H, effect.end.y[1] * H) : H / 2
  };

  img.style.width = ss + "px";
  img.style.opacity = 1;
  stage.appendChild(img);
  items.push(item);
}

for (let i = 0; i < COUNT; i++) {
  setTimeout(spawnItem, i * effect.spawnInterval);
}

/* ==============================
   ğŸ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
================================ */
function animate(now) {
  items.forEach(it => {
    if (it.dead) return;

    const elapsed = now - it.startTime;
    const total = effect.duration;
    const t = Math.min(elapsed / total, 1);

    let x = it.sx;
    let y = it.sy;
    let size = it.ss;
    let rotate = 0;

    /* ===== popï¼ˆæ–°ä»•æ§˜ãƒ»å¸¸æ™‚æºã‚Œï¼‰ ===== */
    if (effect.type === "pop") {
    
      // å…±é€šã®æºã‚Œï¼ˆæç”»ä¸­ãšã£ã¨ï¼‰
      const floatY = Math.sin(t * 8 + it.phase) * 18;
      const swayRot = Math.sin(t * 6 + it.phase) * 8;
    
      if (t < 0.2) {
        const p = easeOutExpo(t / 0.2);
        x = W / 2;
        y = H + (H / 2 - H) * p + floatY;
      }
      else if (t < 0.8) {
        x = W / 2;
        y = H / 2 + floatY;
      }
      else {
        const p = (t - 0.8) / 0.2;
        x = W / 2;
        y = H / 2 + easeOutExpo(p) * (H / 2 + 200) + floatY;
        it.el.style.opacity = 1 - p;
      }
    
      rotate = swayRot;
    }

    /* ===== popular_vote è»Œé“ï¼ˆä¸Šã«è¡Œãã»ã©åŠ é€Ÿï¼‰ ===== */
    if (effect.type === "popular") {
    
      const p = Math.min(elapsed / total, 1);
    
      // Xï¼šç­‰é€Ÿï¼ˆfloatåŸºæº–ï¼‰
      x = it.sx + (it.ex - it.sx) * p;
    
      // Yï¼šåŠ é€Ÿï¼ˆæœ€åˆã‚†ã£ãã‚Š â†’ æœ€å¾Œãã‚…ã£ï¼‰
      const py = p * p; // ease-in
      y = it.sy + (it.ey - it.sy) * py;
    
      rotate = 0;
    
      // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
      if (p > 0.85) {
        it.el.style.opacity = 1 - (p - 0.85) / 0.15;
      }
    }


    /* ===== throwï¼ˆåŸå‹ãã®ã¾ã¾ï¼‰ ===== */
    if (effect.type === "throw") {
      if (elapsed < CHARGE_TIME) {
        const shake = Math.sin(elapsed / 50) * SHAKE_POWER;
        x = it.sx + shake;
        y = it.sy;
        rotate = it.rotBase + shake * 0.5;
      } else {
        const throwT = Math.min(
          (elapsed - CHARGE_TIME) / (total - CHARGE_TIME),
          1
        );
        const p = easeOutExpo(throwT);

        if (p < 0.85 && !it.state) {
          x = it.sx + (it.ex - it.sx) * p;
          y = it.sy + (it.ey - it.sy) * p;
          size = it.ss + (it.es - it.ss) * p;
          rotate = it.rotBase + (1 - p) * 360;
        } else {
          if (!it.state) {
            it.state = "fall";
            it.x = it.ex;
            it.y = it.ey;
            it.vy = -IMPACT_BOUNCE * 0.1;
          }
          it.vy += 1.2;
          it.y += it.vy;
          x = it.x;
          y = it.y;
          size = it.es;
        }
      }
      if (t > 0.85) it.el.style.opacity = 1 - (t - 0.85) / 0.15;
    }

    /* ===== floatï¼ˆåŸå‹ãã®ã¾ã¾ï¼‰ ===== */
    if (effect.type === "float") {
      x = it.sx + (it.ex - it.sx) * t;
      y = it.sy + Math.sin(t * 6 + it.phase) * 20;
      rotate = Math.sin(t * 4 + it.phase) * 15;
      if (t > 0.85) it.el.style.opacity = 1 - (t - 0.85) / 0.15;
    }

    it.el.style.transform =
      `translate(${x - size / 2}px, ${y - size / 2}px) rotate(${rotate}deg)`;
    it.el.style.width = size + "px";

    /* ===== å®Œå…¨å‰Šé™¤ ===== */
    if (elapsed > total) {
      it.el.remove();
      it.dead = true;
    }
  });

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>

</body>
</html>
